'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

const Path = require('path');
const _ = require('lodash');
const Promise = require('bluebird');
const glob = require('glob');
const Locator = require('./locator.js');

/**
 * Parser is responsible for matching all of the instances of the Gitdown JSON and invoking
 * the associated operator functions. Operator functions are invoked in the order of the weight
 * associated with each function. Each operator function is passed the markdown document in
 * its present state (with alterations as a result of the preceding operator functions) and the
 * config from the JSON. This process is repeated until all commands have been executed and
 * parsing the document does not result in alteration of its state, i.e. there are no more Gitdown
 * JSON hooks that could have been generated by either of the preceding operator functions.
 *
 * @param {Gitdown} gitdown
 * @returns {Parser}
 */
const Parser = gitdown => {
  let bindingIndex;

  bindingIndex = 0;

  const helpers = {};
  const parser = {};

  /**
   * Iterates markdown parsing and execution of the parsed commands until all of the
   * commands have been executed and the document does not no longer change after parsing it.
   *
   * @param {string} markdown
   * @param {Array} commands
   * @returns {Promise} Promise is resolved with the state object.
   */
  parser.play = function (markdown) {
    let commands = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

    return Promise.try(_asyncToGenerator(function* () {
      const state = parser.parse(markdown, commands);
      const actState = yield parser.execute(state);

      actState.commands.filter(function (command) {
        return !command.executed;
      });

      if (actState.done) {
        return actState;
      } else {
        return parser.play(actState.markdown, actState.commands);
      }
    }));
  };

  /**
   * Parses the markdown for Gitdown JSON. Replaces the said JSON with placeholders for
   * the output of the command defined in the JSON.
   *
   * @see http://stackoverflow.com/questions/26910402/regex-to-match-json-in-a-document/26910403
   * @param {string} inputMarkdown
   * @param {Array} commands
   */
  parser.parse = (inputMarkdown, commands) => {
    let outputMarkdown;

    const ignoreSection = [];

    outputMarkdown = inputMarkdown;

    // console.log('\n\n\n\ninput markdown:\n\n', markdown);

    // @see http://regex101.com/r/zO0eV6/2
    // console.log('markdown (before)', markdown);

    // /[\s\S]/ is an equivalent of /./m
    outputMarkdown = outputMarkdown.replace(/<!--\sgitdown:\soff\s-->[\s\S]*?(?:$|<!--\sgitdown:\son\s-->)/g, match => {
      ignoreSection.push(match);

      return '⊂⊂I:' + ignoreSection.length + '⊃⊃';
    });

    outputMarkdown = outputMarkdown.replace(/({"gitdown"(?:[^}]+}))/g, match => {
      let command;

      try {
        command = JSON.parse(match);
      } catch (error) {
        throw new Error('Invalid Gitdown JSON ("' + match + '").');
      }

      const name = command.gitdown;
      const config = command;

      delete config.gitdown;

      bindingIndex++;

      if (!helpers[name]) {
        throw new Error('Unknown helper "' + name + '".');
      }

      commands.push({
        bindingIndex: bindingIndex,
        config: config,
        executed: false,
        helper: helpers[name],
        name: name
      });

      return '⊂⊂C:' + bindingIndex + '⊃⊃';
    });

    outputMarkdown = outputMarkdown.replace(/⊂⊂I:([0-9]+)⊃⊃/g, (match, p1) => {
      return ignoreSection[parseInt(p1, 10) - 1];
    });

    return {
      commands: commands,
      markdown: outputMarkdown
    };
  };

  /**
   * Execute all of the commands sharing the lowest common weight against
   * the current state of the markdown document.
   *
   * @param {Object} state
   * @returns {Promise} Promise resolves to a state after all of the commands have been resolved.
   */
  parser.execute = (() => {
    var _ref2 = _asyncToGenerator(function* (state) {
      const notExecutedCommands = state.commands.filter(function (command) {
        return !command.executed;
      });

      if (!notExecutedCommands.length) {
        state.done = true;

        return Promise.resolve(state);
      }

      // Find the lowest weight among all of the not executed commands.
      const lowestWeight = _.minBy(notExecutedCommands, 'helper.weight').helper.weight;

      // Find all commands with the lowest weight.
      const lowestWeightCommands = _.filter(notExecutedCommands, function (command) {
        return command.helper.weight === lowestWeight;
      });

      // Execute each command and update markdown binding.
      yield Promise.resolve(lowestWeightCommands).each((() => {
        var _ref3 = _asyncToGenerator(function* (command) {
          const context = {
            gitdown: gitdown,
            locator: Locator,
            markdown: state.markdown,
            parser: parser
          };

          const value = yield Promise.resolve(command.helper.compile(command.config, context));

          state.markdown = state.markdown.replace('⊂⊂C:' + command.bindingIndex + '⊃⊃', value);

          command.executed = true;
        });

        return function (_x3) {
          return _ref3.apply(this, arguments);
        };
      })());

      return state;
    });

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  })();

  /**
   * Load in-built helpers.
   *
   * @private
   */
  parser.loadHelpers = () => {
    glob.sync(Path.resolve(__dirname, './helpers/*.js')).forEach(helper => {
      // eslint-disable-next-line global-require
      parser.registerHelper(Path.basename(helper, '.js'), require(helper));
    });
  };

  /**
   * @param {string} name
   * @param {Object} helper
   */
  parser.registerHelper = function (name) {
    let helper = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (helpers[name]) {
      throw new Error('There is already a helper with a name "' + name + '".');
    }

    if (_.isUndefined(helper.weight)) {
      helper.weight = 10;
    }

    if (_.isUndefined(helper.compile)) {
      throw new Error('Helper object must defined "compile" property.');
    }

    helpers[name] = helper;
  };

  /**
   * @returns {Object}
   */
  parser.helpers = () => {
    return helpers;
  };

  parser.loadHelpers();

  return parser;
};

module.exports = Parser;
//# sourceMappingURL=parser.js.map