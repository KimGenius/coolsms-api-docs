{"version":3,"sources":["../src/parser.js"],"names":["Path","require","_","Promise","glob","Locator","Parser","gitdown","bindingIndex","helpers","parser","play","markdown","commands","try","state","parse","actState","execute","filter","command","executed","done","inputMarkdown","outputMarkdown","ignoreSection","replace","match","push","length","JSON","error","Error","name","config","helper","p1","parseInt","notExecutedCommands","resolve","lowestWeight","minBy","weight","lowestWeightCommands","each","context","locator","value","compile","loadHelpers","sync","__dirname","forEach","registerHelper","basename","isUndefined","module","exports"],"mappings":"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","file":"parser.js","sourcesContent":["const Path = require('path');\nconst _ = require('lodash');\nconst Promise = require('bluebird');\nconst glob = require('glob');\nconst Locator = require('./locator.js');\n\n/**\n * Parser is responsible for matching all of the instances of the Gitdown JSON and invoking\n * the associated operator functions. Operator functions are invoked in the order of the weight\n * associated with each function. Each operator function is passed the markdown document in\n * its present state (with alterations as a result of the preceding operator functions) and the\n * config from the JSON. This process is repeated until all commands have been executed and\n * parsing the document does not result in alteration of its state, i.e. there are no more Gitdown\n * JSON hooks that could have been generated by either of the preceding operator functions.\n *\n * @param {Gitdown} gitdown\n * @returns {Parser}\n */\nconst Parser = (gitdown) => {\n  let bindingIndex;\n\n  bindingIndex = 0;\n\n  const helpers = {};\n  const parser = {};\n\n  /**\n   * Iterates markdown parsing and execution of the parsed commands until all of the\n   * commands have been executed and the document does not no longer change after parsing it.\n   *\n   * @param {string} markdown\n   * @param {Array} commands\n   * @returns {Promise} Promise is resolved with the state object.\n   */\n  parser.play = (markdown, commands = []) => {\n    return Promise\n      .try(async () => {\n        const state = parser.parse(markdown, commands);\n        const actState = await parser.execute(state);\n\n        actState.commands\n              .filter((command) => {\n                return !command.executed;\n              });\n\n        if (actState.done) {\n          return actState;\n        } else {\n          return parser.play(actState.markdown, actState.commands);\n        }\n      });\n  };\n\n  /**\n   * Parses the markdown for Gitdown JSON. Replaces the said JSON with placeholders for\n   * the output of the command defined in the JSON.\n   *\n   * @see http://stackoverflow.com/questions/26910402/regex-to-match-json-in-a-document/26910403\n   * @param {string} inputMarkdown\n   * @param {Array} commands\n   */\n  parser.parse = (inputMarkdown, commands) => {\n    let outputMarkdown;\n\n    const ignoreSection = [];\n\n    outputMarkdown = inputMarkdown;\n\n    // console.log('\\n\\n\\n\\ninput markdown:\\n\\n', markdown);\n\n    // @see http://regex101.com/r/zO0eV6/2\n    // console.log('markdown (before)', markdown);\n\n    // /[\\s\\S]/ is an equivalent of /./m\n    outputMarkdown = outputMarkdown.replace(/<!--\\sgitdown:\\soff\\s-->[\\s\\S]*?(?:$|<!--\\sgitdown:\\son\\s-->)/g, (match) => {\n      ignoreSection.push(match);\n\n      return '⊂⊂I:' + ignoreSection.length + '⊃⊃';\n    });\n\n    outputMarkdown = outputMarkdown.replace(/({\"gitdown\"(?:[^}]+}))/g, (match) => {\n      let command;\n\n      try {\n        command = JSON.parse(match);\n      } catch (error) {\n        throw new Error('Invalid Gitdown JSON (\"' + match + '\").');\n      }\n\n      const name = command.gitdown;\n      const config = command;\n\n      delete config.gitdown;\n\n      bindingIndex++;\n\n      if (!helpers[name]) {\n        throw new Error('Unknown helper \"' + name + '\".');\n      }\n\n      commands.push({\n        bindingIndex,\n        config,\n        executed: false,\n        helper: helpers[name],\n        name\n      });\n\n      return '⊂⊂C:' + bindingIndex + '⊃⊃';\n    });\n\n    outputMarkdown = outputMarkdown.replace(/⊂⊂I:([0-9]+)⊃⊃/g, (match, p1) => {\n      return ignoreSection[parseInt(p1, 10) - 1];\n    });\n\n    return {\n      commands,\n      markdown: outputMarkdown\n    };\n  };\n\n  /**\n   * Execute all of the commands sharing the lowest common weight against\n   * the current state of the markdown document.\n   *\n   * @param {Object} state\n   * @returns {Promise} Promise resolves to a state after all of the commands have been resolved.\n   */\n  parser.execute = async (state) => {\n    const notExecutedCommands = state.commands.filter((command) => {\n      return !command.executed;\n    });\n\n    if (!notExecutedCommands.length) {\n      state.done = true;\n\n      return Promise.resolve(state);\n    }\n\n    // Find the lowest weight among all of the not executed commands.\n    const lowestWeight = _.minBy(notExecutedCommands, 'helper.weight').helper.weight;\n\n    // Find all commands with the lowest weight.\n    const lowestWeightCommands = _.filter(notExecutedCommands, (command) => {\n      return command.helper.weight === lowestWeight;\n    });\n\n    // Execute each command and update markdown binding.\n    await Promise\n      .resolve(lowestWeightCommands)\n      .each(async (command) => {\n        const context = {\n          gitdown,\n          locator: Locator,\n          markdown: state.markdown,\n          parser\n        };\n\n        const value = await Promise.resolve(command.helper.compile(command.config, context));\n\n        state.markdown = state.markdown.replace('⊂⊂C:' + command.bindingIndex + '⊃⊃', value);\n\n        command.executed = true;\n      });\n\n    return state;\n  };\n\n  /**\n   * Load in-built helpers.\n   *\n   * @private\n   */\n  parser.loadHelpers = () => {\n    glob.sync(Path.resolve(__dirname, './helpers/*.js')).forEach((helper) => {\n            // eslint-disable-next-line global-require\n      parser.registerHelper(Path.basename(helper, '.js'), require(helper));\n    });\n  };\n\n  /**\n   * @param {string} name\n   * @param {Object} helper\n   */\n  parser.registerHelper = (name, helper = {}) => {\n    if (helpers[name]) {\n      throw new Error('There is already a helper with a name \"' + name + '\".');\n    }\n\n    if (_.isUndefined(helper.weight)) {\n      helper.weight = 10;\n    }\n\n    if (_.isUndefined(helper.compile)) {\n      throw new Error('Helper object must defined \"compile\" property.');\n    }\n\n    helpers[name] = helper;\n  };\n\n  /**\n   * @returns {Object}\n   */\n  parser.helpers = () => {\n    return helpers;\n  };\n\n  parser.loadHelpers();\n\n  return parser;\n};\n\nmodule.exports = Parser;\n"]}